package test;

import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;

import javax.net.ssl.SNIServerName;
import javax.net.ssl.SSLSession;

import org.joda.beans.Bean;
import org.joda.beans.BeanDefinition;
import org.joda.beans.ImmutableBean;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaProperty;
import org.joda.beans.Property;
import org.joda.beans.PropertyDefinition;
import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
import org.joda.beans.impl.direct.DirectMetaBean;
import org.joda.beans.impl.direct.DirectMetaProperty;
import org.joda.beans.impl.direct.DirectMetaPropertyMap;

import com.lfp.joe.beans.JodaBeans;
import com.lfp.joe.utils.Utils;
import com.lfp.tls.proxy.core.SessionInitCallbackLFP;

import tlschannel.TlsChannel;

@BeanDefinition
public class KeyContext implements ImmutableBean {

	public static void requirePresent(SelectionKey selectionKey) {
		Objects.requireNonNull(selectionKey);
		synchronized (selectionKey) {
			KeyContext kc = Utils.Types.tryCast(selectionKey.attachment(), KeyContext.class).orElse(null);
			Objects.requireNonNull(kc, () -> "selection key does not contain a required key context:" + selectionKey);
		}
	}

	public static void copy(SelectionKey from, SelectionKey to) {
		copy(from, to, false);
	}

	public static void copy(SelectionKey from, SelectionKey to, boolean replace) {
		Objects.requireNonNull(to);
		access(from, kc1 -> access(to, kc2 -> {
			if (replace)
				return kc1;
			return JodaBeans.copyToBuilder(kc1, kc2.toBuilder()).build();
		}));
	}

	public static KeyContext get(SelectionKey selectionKey) {
		return access(selectionKey, v -> v, v -> v);
	}

	public static KeyContext access(SelectionKey selectionKey, Function<KeyContext, KeyContext> accessor) {
		return access(selectionKey, accessor, v -> v);
	}

	public static <X> X access(SelectionKey selectionKey, Function<KeyContext, KeyContext> accessor,
			Function<KeyContext, X> valueGetter) {
		Objects.requireNonNull(selectionKey);
		Objects.requireNonNull(accessor);
		Objects.requireNonNull(valueGetter);
		synchronized (selectionKey) {
			KeyContext kc = Utils.Types.tryCast(selectionKey.attachment(), KeyContext.class)
					.orElse(KeyContext.builder().build());
			kc = Objects.requireNonNull(accessor.apply(kc));
			selectionKey.attach(kc);
			return valueGetter.apply(kc);
		}
	}

	@PropertyDefinition
	private final TlsChannel tlsChannel;

	@PropertyDefinition
	private final SocketChannel forwardChannel;

	public Optional<SNIServerName> getSNIServerName() {
		return getSSLSessionCallback().flatMap(v -> v.getSNIServerName());
	}

	public Optional<SSLSession> getSSLSession() {
		return getSSLSessionCallback().flatMap(v -> v.getSSLSession());
	}

	public Optional<SessionInitCallbackLFP> getSSLSessionCallback() {
		if (tlsChannel == null)
			return Optional.empty();
		var sessionInitCallback = tlsChannel.getSessionInitCallback();
		if (!(sessionInitCallback instanceof SessionInitCallbackLFP))
			return Optional.empty();
		return Optional.of((SessionInitCallbackLFP) sessionInitCallback);
	}

	public static void main(String[] args) {
		JodaBeans.updateCode();
	}

	// ------------------------- AUTOGENERATED START -------------------------
	/// CLOVER:OFF
	/**
	 * The meta-bean for {@code KeyContext}.
	 * 
	 * @return the meta-bean, not null
	 */
	public static KeyContext.Meta meta() {
		return KeyContext.Meta.INSTANCE;
	}

	static {
		JodaBeanUtils.registerMetaBean(KeyContext.Meta.INSTANCE);
	}

	/**
	 * Returns a builder used to create an instance of the bean.
	 * 
	 * @return the builder, not null
	 */
	public static KeyContext.Builder builder() {
		return new KeyContext.Builder();
	}

	/**
	 * Restricted constructor.
	 * 
	 * @param builder the builder to copy from, not null
	 */
	protected KeyContext(KeyContext.Builder builder) {
		this.tlsChannel = builder.tlsChannel;
		this.forwardChannel = builder.forwardChannel;
	}

	@Override
	public KeyContext.Meta metaBean() {
		return KeyContext.Meta.INSTANCE;
	}

	@Override
	public <R> Property<R> property(String propertyName) {
		return metaBean().<R>metaProperty(propertyName).createProperty(this);
	}

	@Override
	public Set<String> propertyNames() {
		return metaBean().metaPropertyMap().keySet();
	}

	// -----------------------------------------------------------------------
	/**
	 * Gets the tlsChannel.
	 * 
	 * @return the value of the property
	 */
	public TlsChannel getTlsChannel() {
		return tlsChannel;
	}

	// -----------------------------------------------------------------------
	/**
	 * Gets the forwardChannel.
	 * 
	 * @return the value of the property
	 */
	public SocketChannel getForwardChannel() {
		return forwardChannel;
	}

	// -----------------------------------------------------------------------
	/**
	 * Returns a builder that allows this bean to be mutated.
	 * 
	 * @return the mutable builder, not null
	 */
	public Builder toBuilder() {
		return new Builder(this);
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj != null && obj.getClass() == this.getClass()) {
			KeyContext other = (KeyContext) obj;
			return JodaBeanUtils.equal(tlsChannel, other.tlsChannel)
					&& JodaBeanUtils.equal(forwardChannel, other.forwardChannel);
		}
		return false;
	}

	@Override
	public int hashCode() {
		int hash = getClass().hashCode();
		hash = hash * 31 + JodaBeanUtils.hashCode(tlsChannel);
		hash = hash * 31 + JodaBeanUtils.hashCode(forwardChannel);
		return hash;
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(96);
		buf.append("KeyContext{");
		int len = buf.length();
		toString(buf);
		if (buf.length() > len) {
			buf.setLength(buf.length() - 2);
		}
		buf.append('}');
		return buf.toString();
	}

	protected void toString(StringBuilder buf) {
		buf.append("tlsChannel").append('=').append(JodaBeanUtils.toString(tlsChannel)).append(',').append(' ');
		buf.append("forwardChannel").append('=').append(JodaBeanUtils.toString(forwardChannel)).append(',').append(' ');
	}

	// -----------------------------------------------------------------------
	/**
	 * The meta-bean for {@code KeyContext}.
	 */
	public static class Meta extends DirectMetaBean {
		/**
		 * The singleton instance of the meta-bean.
		 */
		static final Meta INSTANCE = new Meta();

		/**
		 * The meta-property for the {@code tlsChannel} property.
		 */
		private final MetaProperty<TlsChannel> tlsChannel = DirectMetaProperty.ofImmutable(this, "tlsChannel",
				KeyContext.class, TlsChannel.class);
		/**
		 * The meta-property for the {@code forwardChannel} property.
		 */
		private final MetaProperty<SocketChannel> forwardChannel = DirectMetaProperty.ofImmutable(this,
				"forwardChannel", KeyContext.class, SocketChannel.class);
		/**
		 * The meta-properties.
		 */
		private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(this, null,
				"tlsChannel", "forwardChannel");

		/**
		 * Restricted constructor.
		 */
		protected Meta() {
		}

		@Override
		protected MetaProperty<?> metaPropertyGet(String propertyName) {
			switch (propertyName.hashCode()) {
			case 2006012808: // tlsChannel
				return tlsChannel;
			case -970995074: // forwardChannel
				return forwardChannel;
			}
			return super.metaPropertyGet(propertyName);
		}

		@Override
		public KeyContext.Builder builder() {
			return new KeyContext.Builder();
		}

		@Override
		public Class<? extends KeyContext> beanType() {
			return KeyContext.class;
		}

		@Override
		public Map<String, MetaProperty<?>> metaPropertyMap() {
			return metaPropertyMap$;
		}

		// -----------------------------------------------------------------------
		/**
		 * The meta-property for the {@code tlsChannel} property.
		 * 
		 * @return the meta-property, not null
		 */
		public final MetaProperty<TlsChannel> tlsChannel() {
			return tlsChannel;
		}

		/**
		 * The meta-property for the {@code forwardChannel} property.
		 * 
		 * @return the meta-property, not null
		 */
		public final MetaProperty<SocketChannel> forwardChannel() {
			return forwardChannel;
		}

		// -----------------------------------------------------------------------
		@Override
		protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
			switch (propertyName.hashCode()) {
			case 2006012808: // tlsChannel
				return ((KeyContext) bean).getTlsChannel();
			case -970995074: // forwardChannel
				return ((KeyContext) bean).getForwardChannel();
			}
			return super.propertyGet(bean, propertyName, quiet);
		}

		@Override
		protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
			metaProperty(propertyName);
			if (quiet) {
				return;
			}
			throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
		}

	}

	// -----------------------------------------------------------------------
	/**
	 * The bean-builder for {@code KeyContext}.
	 */
	public static class Builder extends DirectFieldsBeanBuilder<KeyContext> {

		private TlsChannel tlsChannel;
		private SocketChannel forwardChannel;

		/**
		 * Restricted constructor.
		 */
		protected Builder() {
		}

		/**
		 * Restricted copy constructor.
		 * 
		 * @param beanToCopy the bean to copy from, not null
		 */
		protected Builder(KeyContext beanToCopy) {
			this.tlsChannel = beanToCopy.getTlsChannel();
			this.forwardChannel = beanToCopy.getForwardChannel();
		}

		// -----------------------------------------------------------------------
		@Override
		public Object get(String propertyName) {
			switch (propertyName.hashCode()) {
			case 2006012808: // tlsChannel
				return tlsChannel;
			case -970995074: // forwardChannel
				return forwardChannel;
			default:
				throw new NoSuchElementException("Unknown property: " + propertyName);
			}
		}

		@Override
		public Builder set(String propertyName, Object newValue) {
			switch (propertyName.hashCode()) {
			case 2006012808: // tlsChannel
				this.tlsChannel = (TlsChannel) newValue;
				break;
			case -970995074: // forwardChannel
				this.forwardChannel = (SocketChannel) newValue;
				break;
			default:
				throw new NoSuchElementException("Unknown property: " + propertyName);
			}
			return this;
		}

		@Override
		public Builder set(MetaProperty<?> property, Object value) {
			super.set(property, value);
			return this;
		}

		/**
		 * @deprecated Use Joda-Convert in application code
		 */
		@Override
		@Deprecated
		public Builder setString(String propertyName, String value) {
			setString(meta().metaProperty(propertyName), value);
			return this;
		}

		/**
		 * @deprecated Use Joda-Convert in application code
		 */
		@Override
		@Deprecated
		public Builder setString(MetaProperty<?> property, String value) {
			super.setString(property, value);
			return this;
		}

		/**
		 * @deprecated Loop in application code
		 */
		@Override
		@Deprecated
		public Builder setAll(Map<String, ? extends Object> propertyValueMap) {
			super.setAll(propertyValueMap);
			return this;
		}

		@Override
		public KeyContext build() {
			return new KeyContext(this);
		}

		// -----------------------------------------------------------------------
		/**
		 * Sets the tlsChannel.
		 * 
		 * @param tlsChannel the new value
		 * @return this, for chaining, not null
		 */
		public Builder tlsChannel(TlsChannel tlsChannel) {
			this.tlsChannel = tlsChannel;
			return this;
		}

		/**
		 * Sets the forwardChannel.
		 * 
		 * @param forwardChannel the new value
		 * @return this, for chaining, not null
		 */
		public Builder forwardChannel(SocketChannel forwardChannel) {
			this.forwardChannel = forwardChannel;
			return this;
		}

		// -----------------------------------------------------------------------
		@Override
		public String toString() {
			StringBuilder buf = new StringBuilder(96);
			buf.append("KeyContext.Builder{");
			int len = buf.length();
			toString(buf);
			if (buf.length() > len) {
				buf.setLength(buf.length() - 2);
			}
			buf.append('}');
			return buf.toString();
		}

		protected void toString(StringBuilder buf) {
			buf.append("tlsChannel").append('=').append(JodaBeanUtils.toString(tlsChannel)).append(',').append(' ');
			buf.append("forwardChannel").append('=').append(JodaBeanUtils.toString(forwardChannel)).append(',')
					.append(' ');
		}

	}

	/// CLOVER:ON
	// -------------------------- AUTOGENERATED END --------------------------
}
